//////////////////////////////////////////////////////////////////////////
// FileName:    WordFont.cpp
// Description: Defines all methods of the interface WordFont.h
// Author:      Terry Weiss 466751950
// Project:     Character Fonts (Homework 5 Assignment)
//////////////////////////////////////////////////////////////////////////

#include "WordFont.h"


WordFont::WordFont()
{
    plainWord = "";
    pixelChar = '*';
    fontSize  = MIN_FONT_SIZE;
    isBold    = false;


}

void WordFont::go()
{
    promptWord();
    promptPixelCharacter();
    promptFontSize();
    promptBold();

    drawWord();

    printDrawnWord();
}


void WordFont::promptWord()
{
    std::cout << "Enter a word (8 letters or less): ";
    std::cin >> plainWord;
}

void WordFont::promptPixelCharacter()
{
    std::cout << "Enter the pixel character you want to use to draw: ";
    std::cin >> pixelChar;
}

void WordFont::promptFontSize()
{
    std::cout << "Enter the font size (8-12): ";
    std::cin >> fontSize;
}

void WordFont::promptBold()
{
    std::string input;

    std::cout << "Bold [y/N]? ";
    std::cin >> input;

    isBold = (input == "y");
}


//Draws an A
void WordFont::drawA(const size_t location)
{
    std::bitset<LETTER_SEGMENTS> segments;
//    segments |= SEG_TOP | SEG_TOP_LEFT | SEG_TOP_RIGHT | SEG_MID_LEFT | SEG_MID_RIGHT | SEG_BOT_LEFT | SEG_BOT_RIGHT;
    segments.set(SEG_TOP);
    segments.set(SEG_TOP_LEFT);

    std::vector<bool> letter(fontSize * fontSize, false);
    drawLetter(letter, segments);
    drawnWord[location] = letter;

    size_t nextA = plainWord.find_first_of("Aa", location + 1);
    while (nextA != std::string::npos)
    {
        drawnWord[nextA] = letter;
        nextA = plainWord.find_first_of("Aa", nextA + 1);
    }
}

void WordFont::drawLetter(std::vector<bool> &letter, const std::bitset<LETTER_SEGMENTS> &letterSegments)
{
    if (letterSegments.test(SEG_TOP))
    {
        for (size_t column = 0; column < fontSize; column++)
        {
            letter[column] = true;
            if (isBold)
            {
                letter[column + fontSize] = true;
            }
        }
    }

    if (letterSegments.test(SEG_TOP_LEFT))
    {
        for (size_t row = 0; row < (fontSize + 1) / 2; row++)
        {
            letter[row * fontSize] = true;
            if (isBold)
            {
                letter[row * fontSize + 1] = true;
            }
        }
    }

    if (letterSegments.test(SEG_TOP_LDIAG))
    {
        for (size_t row = 0; row <= fontSize / 2; row++)
        {

        }
    }
}

void WordFont::drawWord()
{
    drawnWord.clear();
    drawnWord.resize(plainWord.size());

    for (size_t letterIndex = 0; letterIndex < plainWord.size(); letterIndex++)
    {
        if (drawnWord[letterIndex].empty())
        {
            switch (plainWord[letterIndex])
            {
            case 'a':
            case 'A':
                drawA(letterIndex);
                break;
/*            case 'b':
            case 'B':
                drawB(letterIndex);
                break;
            case 'c':
            case 'C':
                drawC(letterIndex);
                break;
            case 'd':
            case 'D':
                drawD(letterIndex);
                break;
            case 'e':
            case 'E':
                drawE(letterIndex);
                break;
            case 'f':
            case 'F':
                drawF(letterIndex);
                break;
            case 'g':
            case 'G':
                drawG(letterIndex);
                break;
            case 'h':
            case 'H':
                drawH(letterIndex);
                break;
            case 'i':
            case 'I':
                drawI(letterIndex);
                break;
            case 'j':
            case 'J':
                drawJ(letterIndex);
                break;
            case 'k':
            case 'K':
                drawK(letterIndex);
                break;
            case 'l':
            case 'L':
                drawL(letterIndex);
                break;
            case 'm':
            case 'M':
                drawM(letterIndex);
                break;
            case 'n':
            case 'N':
                drawN(letterIndex);
                break;
            case 'o':
            case 'O':
                drawO(letterIndex);
                break;
            case 'p':
            case 'P':
                drawP(letterIndex);
                break;
            case 'q':
            case 'Q':
                drawQ(letterIndex);
                break;
            case 'r':
            case 'R':
                drawR(letterIndex);
                break;
            case 's':
            case 'S':
                drawS(letterIndex);
                break;
            case 't':
            case 'T':
                drawT(letterIndex);
                break;
            case 'u':
            case 'U':
                drawU(letterIndex);
                break;
            case 'v':
            case 'V':
                drawV(letterIndex);
                break;
            case 'w':
            case 'W':
                drawW(letterIndex);
                break;
            case 'x':
            case 'X':
                drawX(letterIndex);
                break;
            case 'y':
            case 'Y':
                drawY(letterIndex);
                break;
            case 'z':
            case 'Z':
                drawZ(letterIndex);
                break;*/
            default:
                break;
            }
        }
    }
}

void WordFont::printDrawnWord()
{
    for (size_t row = 0; row < fontSize; row++)
    {
        for (size_t letter = 0; letter < plainWord.size(); letter++)
        {
            std::cout << "  ";
            for (size_t pixel = 0; pixel < fontSize; pixel++)
            {
                if (drawnWord[letter][row * fontSize + pixel])
                {
                    std::cout << pixelChar;
                }
                else
                {
                    std::cout << ' ';
                }
            }
        }
        std::cout << std::endl;
    }

    std::cout << std::endl;
}
